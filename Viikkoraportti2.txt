Toisen viikon aikana minulle selvisi, miten lineaarisesti skaalautuva RegEx-tulkki pitää käytännössä toteuttaa. Tällöin aiempi rekursiivinen toteutukseni ei ollut enää mahdollinen, sillä rekursion turhien haarojen tunnistaminen on mahdotonta ja haarojen määrä skaalautuu eksponentiaalisesti.

Sen sijaan algoritmin voi toteuttaa lineaarisessa ajassa sen ansiosta, että tilakoneella ei ole muistia eli kulloiseenkin tilaan saavuttaessa aiemmalla polulla ei ole väliä. Tällöin tilojen määrä pysyy vakiona algoritmin edetessä. Tämä vaatii koodin toteuttamisen Thompsonin tapaan yksi askel kerrallaan, jolloin tilakone on useassa tilassa samalla askeleella. Näiden tilojen tallentamiseen käytin hajautustaulukkoon perustuvaa joukkoa NSMutableSet.

Ongelmaksi lineaarisessa toteutuksessa kuitenkin osoittautuu menneiden matchien muistaminen. Koska määritelmällisesti tilakoneella ei ole muistia, mutta määrittelydokumentin mukaisesti regexpistä halutaan ulos myös matchin aloitusindeksi stringissä, dokumentissa on tavallaan kaksi keskenään ristiriitaista toteutusvaatimusta. Eksponentiaalisessa ratkaisussa jokainen haara etenee erikseen ja matchin aloituskohdan muistaminen on triviaalia; lineaarisessa ratkaisussa matchien aloituskohdat tulee tallentaa johonkin erilliseen rakenteeseen, joka pitää kirjaa siitä, missä haarassa tunnistus alkoi minkäkin kirjaimen kohdalla.

Thompsonin tekemä Googlen algoritmi toteuttaa tämän käytännössä vaatimalla kullakin kierroksella matcheilta tiettyä suoritusjärjestystä. Tämä takaa sen, että lopputuloksena saadaan ennustettavasti greedy tai thrifty match; oletusarvoisesti regex-standardina on matchata mahdollisimman pitkään stringiin silloin, kun useampia submatcheja on tarjolla.

Kevyin keksimäni toteutus tälle käytännölle on lisätä ROState-olioon kaksi kokonaislukua, johon tilakone joka kierroksella päivittää haaraa vastaavan matchin aloitusindeksin seuraavaa kierrosta varten. Tällöin matchin sattuessa kohdalle kaikista lopputiloista valitaan se, johon on tallennettu pienin aloitusindeksi.

Suorituskykytestausta en ole vielä lähelläkään, sillä koko viikko on mennyt hyvin tiiviisti paralleelin tilakoneen toteutuksessa ja sen verifioinnissa; mitään regex-operaatioita ei ole vielä toteutettu, tässä vaiheessa algoritmi matchaa ainoastaan stringejä. Aloitusindeksin tallentamisen ansiosta vältytään kuitenkin kulloistenkin tilojen järjestämiseltä spesifiin suoritusjärjestykseen, ja yleinen askel skaalautuu lineaarisesti regexin pituuden m funktiona. Askeleita käydään läpi enintään stringin pituuden verran eli n kappaletta, joten toteutuksen pitäisi olla O(mn).